<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE book [
<!ELEMENT book (chapter*)>
<!ELEMENT chapter (title,type,arguments?,package?,description,seealso*,link*,section,file?)>
<!ELEMENT title (#PCDATA)>
<!ELEMENT type (#PCDATA)>
<!ELEMENT arguments (#PCDATA)>
<!ELEMENT package (#PCDATA)>
<!ELEMENT description (#PCDATA)>
<!ELEMENT seealso (#PCDATA)>
<!ELEMENT link (#PCDATA)>
<!ELEMENT section (#PCDATA)>
<!ELEMENT file (#PCDATA)>
]>
<!--
* restart-case
* restart-bind
* with-simple-restart
* with-condition-restarts

* compute-restarts
* find-restart
* invoke-restart
* invoke-restart-interactively

* cerror
* warn

* continue
* abort
* muffle-warning
- use-value
- store-value

- assert
- check-type

- ed:select-restart-interactively
-->
<book>

<chapter>
   <title>select-restart-interactively</title>
</chapter>

<chapter>
   <title>assert</title>
</chapter>

<chapter>
   <title>check-type</title>
</chapter>

<chapter>
   <title>再起動ってなに</title>
   <type>Tips</type>
   <description>
エラー（やコンディション）を投げる側がそのエラーにどう対応するかという
選択肢を用意しておくような仕組みです。
   </description>
   <seealso>restart-case</seealso>
   <seealso>restart-bind</seealso>
   <seealso>invoke-restart</seealso>
   <seealso>find-restart</seealso>
   <seealso>handler-bind</seealso>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>use-value</title>
   <type>Function</type>
   <arguments>use-value VALUE &amp;optional CONDITION</arguments>
   <package>lisp</package>
   <description>
use-value 再起動を起動して、そのときだけ代わりに VALUE を使うようにします。
もし有効な use-value 再起動が見つからなかった場合は nil を返します。

use-value 再起動について:
  変数の値がおかしかったりしたときに、そのときだけ代わりの値を使うような
  再起動です。
   </description>
   <seealso>store-value</seealso>
   <link>[CLHS Function use-value]</link>
   <link>[CLHS Restart use-value]</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>store-value</title>
   <type>Function</type>
   <arguments>store-value NEW-VALUE &amp;optional CONDITION</arguments>
   <package>lisp</package>
   <description>
store-value 再起動を起動して、変数の値を NEW-VALUE に変更します。
もし有効な store-value 再起動が見つからなかった場合は nil を返します。

store-value 再起動について:
  変数や汎変数の値を変更して処理を続行するような再起動です
  store-value 再起動を用意するときは、再起動の概要にどの変数の値を変更
  するのか書いておきましょう。
   </description>
   <seealso>use-value</seealso>
   <seealso>check-type</seealso>
   <link>[CLHS Function store-value]</link>
   <link>[CLHS Restart store-value]</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>continue</title>
   <type>Function</type>
   <arguments>continue &amp;optional CONDITION</arguments>
   <package>lisp</package>
   <description>
continue 再起動を起動します。
もし有効な continue 再起動が見つからなかった場合は nil を返して終了します。

  CONDITION : コンディションを指定すると、そのコンディションに対応した
              continue 再起動を探して起動します。

continue 再起動について:
  単純に処理を続行するような再起動です。
  ※ 警告 (warning) を無視するときは muffle-warning を使います。
   </description>
   <seealso>restart-case</seealso>
   <seealso>abort</seealso>
   <seealso>muffle-warning</seealso>
   <seealso>store-value</seealso>
   <seealso>use-value</seealso>
   <seealso>invoke-restart</seealso>
   <link>[CLHS Function continue] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_abortc.htm#continue</link>
   <link>[CLHS Restart continue] http://www.lispworks.com/documentation/lw50/CLHS/Body/r_contin.htm</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>abort</title>
   <type>Function</type>
   <arguments>abort &amp;optional CONDITION</arguments>
   <package>lisp</package>
   <description>
abort 再起動を起動して、処理を中止しようとします。
もし有効な abort 再起動が見つからなかった場合は、silent-quit を投げて
処理を中止するかも{{詳細未定}}。

  CONDITION : コンディションを指定すると、そのコンディションに対応した
              abort 再起動を探して起動します。

abort 再起動について:
  処理を中止するような再起動です。
  {{詳細未定: abort 再起動が確立されてない場合}}
   </description>
   <seealso>restart-case</seealso>
   <seealso>invoke-restart</seealso>
   <link>[CLHS abort] http://www.lispworks.com/documentation/lw51/CLHS/Body/f_abortc.htm</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>muffle-warning</title>
   <type>Function</type>
   <arguments>muffle-warning &amp;optional WARNING</arguments>
   <package>lisp</package>
   <description>
muffle-warning 再起動を起動して、警告を無視します。

  WARNING: 警告を指定すると、その警告に対応した muffle-warning を探して
           起動します。

muffle-warning 再起動について:
  警告を無視する再起動です。warn 関数を参照してください。
   </description>
   <seealso></seealso>
   <link>[CLHS Function muffle-warning]</link>
   <link>[CLHS Restart muffle-warning]</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>warn</title>
   <type>Function</type>
   <arguments>warn DATUM &amp;rest ARGS</arguments>
   <package>lisp</package>
   <description>
※これは condition-restart.l で上書きされた warn の説明です。
警告（warning コンディション）を投げます。

warn 関数は、警告を投げるときに muffle-warning 再起動を確立しておきます。
この muffle-warning 再起動を起動すると警告を無視することができます。

  DATUM, ARGS : 投げる警告を指定します。error 関数を参照してください。
                DATUM にフォーマット文字列を指定した場合は、simple-warning
                を投げます。

投げられた警告が無視も処理もされずにトップレベルまで到達すると、xyzzy は
警告音を鳴らしたりします（共通設定->いろいろ で設定できます）が、処理を
中止したりはせず、warn 式からは nil が返ります。
   </description>
   <seealso>error</seealso>
   <seealso>signal</seealso>
   <seealso>muffle-warning</seealso>
   <link>[CLHS Function warn]</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>cerror</title>
   <type>Function</type>
   <arguments>cerror FMT-CONTROL DATUM &amp;rest ARGS</arguments>
   <package>lisp</package>
   <description>
回復可能なエラーを投げます。

関数 error 同様に DATUM（及び ARGUMENTSS）で指定されたエラーを投げますが、
そのときに再起動 continue を確立しておきます。
この continue 再起動を起動すると cerror 式から nil を返して、その後の処理
を続行させることができます。

  FMT-CONTROL : 再起動の概要を出力するフォーマット文字列です。引数として
                ARUMENTS が与えられます。
  DATUM, ARGS : 投げるエラーを指定します。詳しくは error 関数を参照してく
                ださい。

ARGS は再起動の概要とエラー指定の両方に使われます。エラー指定に必要だけど
概要の出力には不要なものは "~*" で無視することができます。

   </description>
   <seealso>signal</seealso>
   <seealso>error</seealso>
   <link>[CLHS cerror] http://www.lispworks.com/documentation/lw51/CLHS/Body/f_cerror.htm#cerror</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>invoke-restart-interactively</title>
   <type>Function</type>
   <arguments>invoke-restart-interactively IDENTIFIER</arguments>
   <package>lisp</package>
   <description>
再起動を対話的に起動します。
invoke-restart-interactively によって起動された再起動は、restart-case の
:interactive オプションや restart-bind の :interactive-function オプション
で指定された関数を実行することで、再起動の引数を対話的に取得します。

  IDENTIFIER : 再起動の名前（シンボル）か再起動オブジェクトを指定します。

   </description>
   <seealso>restart-bind</seealso>
   <seealso>restart-case</seealso>
   <seealso>invoke-restart</seealso>
   <link>[CLHS invoke-restart-interactively] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_invo_2.htm#invoke-restart-interactively</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>find-restart</title>
   <type>Function</type>
   <arguments>find-restart IDENTIFIER &amp;optional CONDITION</arguments>
   <package>lisp</package>
   <description>
指定された再起動を現在の環境から探して返します。
見つからなかったら nil を返します。

  IDENTIFIER : 再起動の名前（シンボル）か再起動オブジェクトを指定します。
  CONDITION  : コンディションを指定すると、そのコンディションに対して有効
               な再起動の中から探します。
               restart-bind の :test-function 参照。

   </description>
   <seealso>restart-bind</seealso>
   <seealso>restart-case</seealso>
   <seealso>compute-restarts</seealso>
   <link>[CLHS find-restart] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_r.htm#find-restart</link>
   <file>condition-restart.l</file>
   <section>エラー</section>
</chapter>

<chapter>
   <title>invoke-restart</title>
   <type>Function</type>
   <arguments>invoke-restart IDENTIFIER &amp;rest ARGUMENTS</arguments>
   <package>lisp</package>
   <description>
IDENTIFIER で指定される再起動を起動します。

  IDENTIFIER : 起動する再起動の名前（シンボル）か再起動オブジェクトを指定
               します。
               指定される再起動が確立されていない場合は restart-not-found
               エラーが通知されます。
  ARGUMENTS  : 再起動に渡す引数があれば。

再起動は制御をどこかに飛ばすかも知れません。飛ばさなかった（普通に値を
返した）場合、invoke-restart は再起動が返した値をそのまま返します。
   </description>
   <seealso>find-restart</seealso>
   <seealso>restart-case</seealso>
   <link>[CLHS invoke-restart] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_invo_1.htm#invoke-restart</link>
   <file>condition-restart.l</file>
   <section>エラー</section>
</chapter>

<chapter>
   <title>compute-restarts</title>
   <type>Function</type>
   <arguments>compute-restarts &amp;optional CONDITION</arguments>
   <package>lisp</package>
   <description>
現在の環境で確立されている再起動のリストを返します。

  CONDITION : コンディションを指定すると、そのコンディションに対して有効な
              再起動のみのリストを返します。
   </description>
   <seealso>restart-case</seealso>
   <seealso>restart-bind</seealso>
   <seealso>with-simple-restart</seealso>
   <seealso>find-restart</seealso>
   <seealso>invoke-restart</seealso>
   <link>[CLHS compute-restarts] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_comp_1.htm#compute-restarts</link>
   <file>condition-restart.l</file>
   <section>エラー</section>
</chapter>

<chapter>
   <title>with-simple-restart</title>
   <type>Macro</type>
   <arguments>with-simple-restart (NAME FMT-CONTROL &amp;rest FMT-ARGUMENTS) &amp;body FORMS</arguments>
   <package>lisp</package>
   <description>
NAME という名前の再起動を確立した環境で FORMS を評価します。
この再起動が起動されると、with-simple-restart 式は多値で nil と t を返して
終了します。
   </description>
   <link>[CLHS: with-simple-restart] http://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_smp_.htm#with-simple-restart</link>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>with-condition-restarts</title>
   <type>Macro</type>
   <arguments>with-condition-restarts CONDITION RESTARTS FORM*</arguments>
   <package>lisp</package>
   <description>
再起動とコンディションを関連付けます。

{{関連付けるってなによ}}

  CONDITION : 関連付けるコンディションを指定します。
              コンディションの型ではなくコンディションオブジェクトを指定
              します。
  RESTARTS  : 関連付ける再起動のリストを指定します。


find-restart や compute-restarts の引数にコンディションを与えて呼び出すと
そのコンディションに関連付けられた再起動（とどのコンディションにも関連付け
られていない再起動）のみを探すことができます。

例えば、いくつか再起動を用意してコンディション FOO が投げられたとします。
それを捕まえたハンドラが、更にいくつかの再起動を追加で用意して別のコンディ
ション BAR を投げたとします。
さらに上位のハンドラがコンディション BAR を捕まえた時点では、上記の全ての
再起動が有効なままですが、コンディション FOO に関連付けられた再起動は無視
してコンディション BAR に関連付けられた再起動の中から選んで起動することが
できたりします。


   </description>
   <seealso>restart-case</seealso>
   <seealso>find-restart</seealso>
   <seealso>compute-restarts</seealso>
   <link>[CLHS Macro with-condition-restarts] http://www.lispworks.com/documentation/HyperSpec/Body/m_w_cnd_.htm#with-condition-restarts</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>restart-case</title>
   <type>Macro</type>
   <arguments>restart-case FORM RESTART-CLAUSE*</arguments>
   <package>lisp</package>
   <description>
RESTART-CLAUSE で指定された再起動を用意して FORM を評価します。

restart-case で用意された再起動が起動されると、再起動の本体を実行し、
その結果を restart-case 式の結果として返します。

  (restart-case
      FORM
    (NAME LAMBDA-LIST
      {:interactive INTERACTIVE-EXPR}
      {:report REPORT-EXPR}
      {:test TEST-EXPR}
      BODY...)
    ...)

  NAME             : 再起動の名前をシンボルで指定します。
  LAMBDA-LIST      : 再起動の仮引数を指定します。lambda とか使うことの
                     できる &amp;optional やら &amp;rest やらを使えます。
  BODY             : 再起動が起動されたときに実行されます。
                     LAMBDA-LIST で指定した仮引数が与えられた引数に束縛され
                     た環境で実行され、BODY の結果が restart-case 式の結果
                     となります。

  INTERACTIVE-EXPR : 対話的に起動されたときに実行される関数を、関数名
                     （シンボルかlambda 式）で指定します。#' はつけない
                     でください。
                     対話的に起動されるとこの関数は引数なしで実行されます。
                     この関数は再起動へ渡す引数のリストを返さなければなり
                     ません。
  REPORT-EXPR      : 再起動の概要を説明する文字列か、概要を出力する関数の
                     名前を指定します。
              関数   : 関数名（シンボルか lambda 式）を指定します。#' はつけ
                       ないでください。関数は出力先のストリームを受け取り、
                       再起動の概要を出力しなければなりません。
              文字列 : 再起動の概要をそのまま文字列で指定します。
  TEST-EXPR        : あるコンディションに対してその再起動が有効か否かを判断
                     する関数の名前を指定します。#' はつけないでください。
                     省略されるとその再起動は全てのコンディションに対して
                     有効になります。

FORM が signal, error, cerror, warn のいずれかで始まる式（か、それに展開され
マクロ呼び出し）だったら、その restart-case で用意される再起動は勝手に投げ
られるコンディションに関連付けられます。

   </description>
   <seealso>invoke-restart</seealso>
   <seealso>with-simple-restart</seealso>
   <seealso>restart-bind</seealso>
   <seealso>with-condition-restarts</seealso>
   <link>[CLHS: restart-case] http://www.lispworks.com/documentation/lw50/CLHS/Body/m_rst_ca.htm</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>restart-bind</title>
   <type>Macro</type>
   <arguments>restart-bind (&amp;rest RESTARTS) &amp;body BODY</arguments>
   <package>lisp</package>
   <description>
再起動を確立した環境で BODY を評価します。

  (restart-bind ((NAME RESTART-FUNCTION
                   {:interactive-function INTERACTIVE-FUNCTION}
                   {:report-function REPORT-FUNCTION}
                   {:test-function TEST-FUNCTION})
                   ...)
    BODY...)

  NAME                 : 再起動の名前（シンボル）です。
  RESTART-FUNCTION     : 再起動が起動されたときに実行される関数を指定します。
  INTERACTIVE-FUNCTION : 再起動が invoke-restart-interactively によって
                         対話的に起動されたときに実行される関数を指定します。
                         この関数は引数なしで実行され、RESTART-FUNCTION に渡す
                         引数のリストを返さなければなりません。
  REPORT-FUNCTION      : 再起動の概要を出力する関数を指定します。
                         REPORT-FUNCTION は引数に出力先のストリームを受け取り、
                         その再起動の概要を出力しなければなりません。
  TEST-FUNCTION        : 通知されたコンディションに対してその再起動が有効か
                         どうかを判断する関数を指定します。
                         この関数は引数にコンディションを受け取り、与えられた
                         コンディションについてその再起動が有効だったら true
                         を返しましょう。

restart-bind は再起動を確立するだけで、それ以上のことをしたい場合は自分
でやらなければなりません（tagbody と go で制御を移すとか）。
大抵の場合は restart-case の方が便利だと思います。
   </description>
   <seealso>with-simple-restart</seealso>
   <seealso>restart-case</seealso>
   <seealso>invoke-restart</seealso>
   <link>[CLHS: restart-bind] http://www.lispworks.com/documentation/lw50/CLHS/Body/m_rst_bi.htm</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

</book>
