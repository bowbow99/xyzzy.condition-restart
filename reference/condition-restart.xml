<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE book [
<!ELEMENT book (chapter*)>
<!ELEMENT chapter (title,type,arguments?,package?,description,seealso*,link*,section,file?)>
<!ELEMENT title (#PCDATA)>
<!ELEMENT type (#PCDATA)>
<!ELEMENT arguments (#PCDATA)>
<!ELEMENT package (#PCDATA)>
<!ELEMENT description (#PCDATA)>
<!ELEMENT seealso (#PCDATA)>
<!ELEMENT link (#PCDATA)>
<!ELEMENT section (#PCDATA)>
<!ELEMENT file (#PCDATA)>
]>
<!--
* restart-case
* restart-bind
* with-simple-restart
- with-condition-restarts

* compute-restarts
* find-restart
* invoke-restart
* invoke-restart-interactively

* cerror
* warn

* continue
* abort
* muffle-warning
- use-value
- store-value

- assert
- check-type

- ed:select-restart-interactively
-->
<book>

<chapter>
   <title>再起動ってなに</title>
   <type>Tips</type>
   <description>
エラー（やコンディション）を投げる側がそのエラーにどう対応するかという
選択肢を用意しておくような仕組みです。

handler-bind(*1) で指定するハンドラ関数など(*2)でエラーを捕まえた側で
再起動を選んで起動することで、エラーを無視して続行させたり、別の値を使
うようにしたりできます。

TODO: {{ここに使用例を}}

*1 handler-case では再起動を選ぶことができません。handler-bind を使う
   必要があります。
   再起動はエラーが投げられたときのダイナミック環境内に用意されますが、
   handler-case のハンドラ（エラー処理部分）はエラーが投げられたときの
   ダイナミック環境から抜けてから実行されるためです。
   詳しくは lisp/handler.l や handler-case の展開系を見てみてください。

*2 {{select-restart-interactively について}}

   </description>
   <seealso>restart-case</seealso>
   <seealso>restart-bind</seealso>
   <seealso>invoke-restart</seealso>
   <seealso>find-restart</seealso>
   <seealso>handler-bind</seealso>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>continue</title>
   <type>Function</type>
   <arguments>continue &amp;optional CONDITION</arguments>
   <package>lisp</package>
   <description>
continue 再起動を起動します。
もし有効な continue 再起動が見つからなかった場合は nil を返して終了します。

  CONDITION : コンディションを指定すると、そのコンディションに対応した
              continue 再起動を探して起動します。

continue 再起動について:
  単純に処理を続行するような再起動です。
  ※ 警告 (warning) を無視するときは muffle-warning を使います。
   </description>
   <seealso>restart-case</seealso>
   <seealso>abort</seealso>
   <seealso>muffle-warning</seealso>
   <seealso>store-value</seealso>
   <seealso>use-value</seealso>
   <seealso>invoke-restart</seealso>
   <link>[CLHS Function continue] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_abortc.htm#continue</link>
   <link>[CLHS Restart continue] http://www.lispworks.com/documentation/lw50/CLHS/Body/r_contin.htm</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>abort</title>
   <type>Function</type>
   <arguments>abort &amp;optional CONDITION</arguments>
   <package>lisp</package>
   <description>
abort 再起動を起動して、処理を中止しようとします。
もし有効な abort 再起動が見つからなかった場合は、silent-quit を投げて
処理を中止するかも{{詳細未定}}

  CONDITION : コンディションを指定すると、そのコンディションに対応した
              abort 再起動を探して起動します。

abort 再起動について:
  処理を中止するような再起動です。
  {{詳細未定: abort 再起動が確立されてない場合}}
   </description>
   <seealso>restart-case</seealso>
   <seealso>invoke-restart</seealso>
   <link>[CLHS abort] http://www.lispworks.com/documentation/lw51/CLHS/Body/f_abortc.htm</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>muffle-warning</title>
   <type>Function</type>
   <arguments>muffle-warning &amp;optional WARNING</arguments>
   <package>lisp</package>
   <description>
muffle-warning 再起動を起動して、警告を無視します。

  WARNING: 警告を指定すると、その警告に対応した muffle-warning を探して
           起動します。

muffle-warning 再起動について:
  警告を無視する再起動です。warn 関数を参照してください。
   </description>
   <seealso></seealso>
   <link>[CLHS Function muffle-warning]</link>
   <link>[CLHS Restart muffle-warning]</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>warn</title>
   <type>Function</type>
   <arguments>warn DATUM &amp;rest ARGS</arguments>
   <package>lisp</package>
   <description>
※これは condition-restart.l で上書きされた warn の説明です。
警告を投げます。

warn 関数は、警告を投げるときに muffle-warning 再起動を確立しておきます。
この muffle-warning 再起動を起動すると warn 式から nil を返して、その後の
処理を続行させることができます。

  DATUM, ARGS : 投げる警告を指定します。error 関数を参照してください。
                DATUM にフォーマット文字列を指定した場合は、simple-warning
                を投げます。

   </description>
   <seealso>error</seealso>
   <seealso>signal</seealso>
   <seealso>muffle-warning</seealso>
   <link>[CLHS Function warn]</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>cerror</title>
   <type>Function</type>
   <arguments>cerror FMT-CONTROL DATUM &amp;rest ARGS</arguments>
   <package>lisp</package>
   <description>
回復可能なエラーを投げます。

関数 error 同様に DATUM（及び ARGUMENTSS）で指定されたエラーを投げますが、
そのときに再起動 continue を確立しておきます。
この continue 再起動を起動すると cerror 式から nil を返して、その後の処理
を続行させることができます。

  FMT-CONTROL : 再起動の概要を出力するフォーマット文字列です。引数として
                ARUMENTS が与えられます。
  DATUM, ARGS : 投げるエラーを指定します。詳しくは error 関数を参照してく
                ださい。

ARGS は再起動の概要とエラー指定の両方に使われます。エラー指定に必要だけど
概要の出力には不要なものは "~*" で無視することができます。

   </description>
   <seealso>signal</seealso>
   <seealso>error</seealso>
   <link>[CLHS cerror] http://www.lispworks.com/documentation/lw51/CLHS/Body/f_cerror.htm#cerror</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>invoke-restart-interactively</title>
   <type>Function</type>
   <arguments>invoke-restart-interactively IDENTIFIER</arguments>
   <package>lisp</package>
   <description>
再起動を対話的に起動します。
invoke-restart-interactively によって起動された再起動は、restart-case の
:interactive オプションや restart-bind の :interactive-function オプション
で指定された関数を実行することで、再起動の引数を対話的に取得します。

  IDENTIFIER : 再起動の名前（シンボル）か再起動オブジェクトを指定します。

   </description>
   <seealso>restart-bind</seealso>
   <seealso>restart-case</seealso>
   <seealso>invoke-restart</seealso>
   <link>[CLHS invoke-restart-interactively] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_invo_2.htm#invoke-restart-interactively</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>find-restart</title>
   <type>Function</type>
   <arguments>find-restart IDENTIFIER &amp;optional CONDITION</arguments>
   <package>lisp</package>
   <description>
指定された再起動を現在の環境から探して返します。
見つからなかったら nil を返します。

  IDENTIFIER : 再起動の名前（シンボル）か再起動オブジェクトを指定します。
  CONDITION  : コンディションを指定すると、そのコンディションに対して有効
               な再起動の中から探します。
               restart-bind の :test-function 参照。

   </description>
   <seealso>restart-bind</seealso>
   <seealso>restart-case</seealso>
   <seealso>compute-restarts</seealso>
   <link>[CLHS find-restart] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_r.htm#find-restart</link>
   <file>condition-restart.l</file>
   <section>エラー</section>
</chapter>

<chapter>
   <title>invoke-restart</title>
   <type>Function</type>
   <arguments>invoke-restart IDENTIFIER &amp;rest ARGUMENTS</arguments>
   <package>lisp</package>
   <description>
IDENTIFIER で指定される再起動を起動します。

  IDENTIFIER : 起動する再起動の名前（シンボル）か再起動オブジェクトを指定
               します。
               指定される再起動が確立されていない場合は restart-not-found
               エラーが通知されます。
  ARGUMENTS  : 再起動に渡す引数があれば。

再起動は制御をどこかに飛ばすかも知れません。飛ばさなかった（普通に値を
返した）場合、invoke-restart は再起動が返した値をそのまま返します。
   </description>
   <seealso>find-restart</seealso>
   <seealso>restart-case</seealso>
   <link>[CLHS invoke-restart] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_invo_1.htm#invoke-restart</link>
   <file>condition-restart.l</file>
   <section>エラー</section>
</chapter>

<chapter>
   <title>compute-restarts</title>
   <type>Function</type>
   <arguments>compute-restarts &amp;optional CONDITION</arguments>
   <package>lisp</package>
   <description>
現在の環境で確立されている再起動のリストを返します。

  CONDITION : コンディションを指定すると、そのコンディションに対して有効な
              再起動のみのリストを返します。
   </description>
   <seealso>restart-case</seealso>
   <seealso>restart-bind</seealso>
   <seealso>with-simple-restart</seealso>
   <seealso>find-restart</seealso>
   <seealso>invoke-restart</seealso>
   <link>[CLHS compute-restarts] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_comp_1.htm#compute-restarts</link>
   <file>condition-restart.l</file>
   <section>エラー</section>
</chapter>

<chapter>
   <title>with-simple-restart</title>
   <type>Macro</type>
   <arguments>with-simple-restart (NAME FMT-CONTROL &amp;rest FMT-ARGUMENTS) &amp;body FORMS</arguments>
   <package>lisp</package>
   <description>
NAME という名前の再起動を確立した環境で FORMS を評価します。
この再起動が起動されると、with-simple-restart 式は多値で nil と t を返して
終了します。
   </description>
   <link>[CLHS: with-simple-restart] http://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_smp_.htm#with-simple-restart</link>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>with-condition-restarts</title>
   <type>Macro</type>
   <arguments>with-condition-restarts CONDITION RESTARTS FORM*</arguments>
   <package>lisp</package>
   <description>
再起動とコンディションを関連付けます。

  CONDITION : 関連付けるコンディションを指定します。
              コンディションの型ではなくコンディションオブジェクトを指定
              します。
  RESTARTS  : 関連付ける再起動のリストを指定します。

find-restart や compute-restarts の引数にコンディションを与えて呼び出すと
そのコンディションに関連付けられた再起動（とどのコンディションにも関連付け
られていない再起動）のみを探すことができます。

例えば、いくつか再起動を用意してコンディション FOO が投げられたとします。
それを捕まえたハンドラが、更にいくつかの再起動を追加で用意して別のコンディ
ション BAR を投げたとします。
さらに上位のハンドラがコンディション BAR を捕まえた時点では、上記の全ての
再起動が有効なままですが、コンディション FOO に関連付けられた再起動は無視
してコンディション BAR に関連付けられた再起動の中から選んで起動することが
できたりします。


   </description>
   <seealso>restart-case</seealso>
   <seealso>find-restart</seealso>
   <seealso>compute-restarts</seealso>
   <link>[CLHS Macro with-condition-restarts] http://www.lispworks.com/documentation/HyperSpec/Body/m_w_cnd_.htm#with-condition-restarts</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>restart-case</title>
   <type>Macro</type>
   <arguments>restart-case FORM RESTART-CLAUSE*</arguments>
   <package>lisp</package>
   <description>
RESTART-CLAUSE で指定された再起動を確立した環境で FORM を評価します。

restart-case で確立された再起動が起動されると、再起動の本体を実行し、
その結果を restart-case 式の結果として返します。

  (restart-case
      FORM
    (NAME LAMBDA-LIST
      {:interactive INTERACTIVE-EXPR}
      {:report REPORT-EXPR}
      {:test TEST-EXPR}
      BODY...)
    ...)

  NAME             : 再起動の名前をシンボルで指定します。
  LAMBDA-LIST      : 再起動の仮引数を指定します。lambda とか使うことの
                     できる &amp;optional やら &amp;rest やらを使えます。
  BODY             : 再起動が起動されたときに実行されます。
                     LAMBDA-LIST で指定した仮引数が与えられた引数に束縛され
                     た環境で実行され、BODY の結果が restart-case 式の結果
                     となります。

  INTERACTIVE-EXPR : 対話的に起動されたときに実行される関数を、関数名
                     （シンボルかlambda 式）で指定します。#' はつけない
                     でください。
                     対話的に起動されるとこの関数は引数なしで実行されます。
                     この関数は再起動へ渡す引数のリストを返さなければなり
                     ません。
  REPORT-EXPR      : 再起動の概要を説明する文字列か、概要を出力する関数の
                     名前を指定します。
              関数   : 関数名（シンボルか lambda 式）を指定します。#' はつけ
                       ないでください。関数は出力先のストリームを受け取り、
                       再起動の概要を出力しなければなりません。
              文字列 : 再起動の概要をそのまま文字列で指定します。
  TEST-EXPR        : あるコンディションに対してその再起動が有効か否かを判断
                     する関数の名前を指定します。#' はつけないでください。
                     省略されるとその再起動は全てのコンディションに対して
                     有効になります。
   </description>
   <seealso>invoke-restart</seealso>
   <seealso>with-simple-restart</seealso>
   <seealso>restart-bind</seealso>
   <seealso>with-condition-restarts</seealso>
   <link>[CLHS: restart-case] http://www.lispworks.com/documentation/lw50/CLHS/Body/m_rst_ca.htm</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

<chapter>
   <title>restart-bind</title>
   <type>Macro</type>
   <arguments>restart-bind (&amp;rest RESTARTS) &amp;body BODY</arguments>
   <package>lisp</package>
   <description>
再起動を確立した環境で BODY を評価します。

  (restart-bind ((NAME RESTART-FUNCTION
                   {:interactive-function INTERACTIVE-FUNCTION}
                   {:report-function REPORT-FUNCTION}
                   {:test-function TEST-FUNCTION})
                   ...)
    BODY...)

  NAME                 : 再起動の名前（シンボル）です。
  RESTART-FUNCTION     : 再起動が起動されたときに実行される関数を指定します。
  INTERACTIVE-FUNCTION : 再起動が invoke-restart-interactively によって
                         対話的に起動されたときに実行される関数を指定します。
                         この関数は引数なしで実行され、RESTART-FUNCTION に渡す
                         引数のリストを返さなければなりません。
  REPORT-FUNCTION      : 再起動の概要を出力する関数を指定します。
                         REPORT-FUNCTION は引数に出力先のストリームを受け取り、
                         その再起動の概要を出力しなければなりません。
  TEST-FUNCTION        : 通知されたコンディションに対してその再起動が有効か
                         どうかを判断する関数を指定します。
                         この関数は引数にコンディションを受け取り、与えられた
                         コンディションについてその再起動が有効だったら true
                         を返しましょう。

restart-bind は再起動を確立するだけで、それ以上のことをしたい場合は自分
でやらなければなりません（tagbody と go で制御を移すとか）。
大抵の場合は restart-case の方が便利だと思います。
   </description>
   <seealso>with-simple-restart</seealso>
   <seealso>restart-case</seealso>
   <seealso>invoke-restart</seealso>
   <link>[CLHS: restart-bind] http://www.lispworks.com/documentation/lw50/CLHS/Body/m_rst_bi.htm</link>
   <section>エラー</section>
   <file>condition-restart.l</file>
</chapter>

</book>
