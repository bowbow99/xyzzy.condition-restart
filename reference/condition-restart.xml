<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE book [
<!ELEMENT book (chapter*)>
<!ELEMENT chapter (title,type,arguments?,package?,description,seealso*,link*,section,file?)>
<!ELEMENT title (#PCDATA)>
<!ELEMENT type (#PCDATA)>
<!ELEMENT arguments (#PCDATA)>
<!ELEMENT package (#PCDATA)>
<!ELEMENT description (#PCDATA)>
<!ELEMENT seealso (#PCDATA)>
<!ELEMENT link (#PCDATA)>
<!ELEMENT section (#PCDATA)>
<!ELEMENT file (#PCDATA)>
]>
<!-- LICENSE: MIT (see COPYING) -->
<!--
reference/condition-restart.xml

xyzzy 用拡張ライブラリ condition-restart で定義している関数やマクロのリファ
レンスです。

参考:
- へなちょこリファレンス http://xyzzy.s53.xrea.com/wiki/index.php?%A5%EA%A5%D5%A5%A1%A5%EC%A5%F3%A5%B9

この XML の使い方
=================
以下のものが必要です。全てネットインストーラから入手できます。
- info-modoki-mode
- reference.xml
- xy-reference

xy-reference で reference.xml とこの XML ファイルから、info-modoki-mode
で読み込める reference.txt を作っておけば、info-modoki-mode で標準の関数
と同様に condition-restart で定義している関数などのリファレンスを参照で
きるようになります。

    ;; *scratch* などで以下を実行する
    (progn
      (require :xy-reference)
      (xy-reference:2txt))

    ;; info-modoki-mode が既に reference.txt を開いているので閉じる
    (delete-buffer *imm-buffer*)
-->
<book>


<chapter>
<title>select-restart-interactively</title>
<type>Function</type>
<arguments>select-restart-interactively CONDITION</arguments>
<package>editor</package>
<description>
対話的に再起動を選んで起動します。

再起動が用意された環境で select-restart-interactively にコンディション
を与えて実行すると、ウィンドウを分割して与えられたコンディションと有効
な再起動を表示し、ミニバッファから再起動を選ぶことができます。

使用例:
  ;;; ミニバッファで入力した式を評価して、エラーが投げられたら対話的に
  ;;; 再起動を選ぶ
  (handler-bind ((error #'ed::select-restart-interactively))
    (eval (read-sexp "FORM: ")))
</description>
<seealso></seealso>
<link></link>
<section>エラー</section>
<file>condition-restart-support.l</file>
</chapter>

<chapter>
<title>read-value</title>
<type>Function</type>
<arguments>read-value PROMPT &amp; PREDICATE</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示して、ユーザーから値の入力を受け付けます。

引数:
  PROMPT     : プロンプト文字列
  PREDICATE  : 値をチェックする関数

PREDICATE を指定すると、入力された値が PREDICATE を満たさない場合にはユ
ーザーに再入力を求めます。
入力された式を評価する際にエラーが発生した場合も、ユーザーに再入力を求め
ます。

例外:
  ユーザーが入力を途中でキャンセルした場合は、エラー quit を投げて終了し
  ます。
</description>
<seealso>read-sexp</seealso>
<file>condition-restart.l</file>
<section>ミニバッファ</section>
</chapter>



<chapter>
<title>assert</title>
<type>Macro</type>
<arguments>assert TEST-FORM {(PLACE*) {DATUM ARGS*}</arguments>
<package>lisp</package>
<description>
TEST-FORM が non-nil に評価されることを確実にします。

引数:
  TEST-FORM   : true を返すはずの任意の式を指定します。
                1回以上評価されます。

  PLACE       : continue 再起動を起動したときに置き換える場所（setf 可能
                な汎変数）を指定します。
                複数回評価されたり、値を変更されたりする可能性があります。
  DATUM, ARGS : 投げるエラーを指定します（error 関数参照）。
                省略した場合は simple-error が投げられます。

TEST-FORM が nil に評価されると、DATUM と ARGS で指定されたエラー（省略
された場合は simple-error）を投げます。
assert は、エラーを投げる際に再起動 continue を用意しておきます。この 
再起動 continue を起動すると、PLACE* の値を与えられた引数（対話的に起動
した場合は、各 PLACE の新しい値をミニバッファから入力できます）に変更し
て、再度 TEST-FORM の評価からやり直します。

使用例:
  (let ((x 1))
    (assert (and (integerp x) (evenp x)) (x)
            "偶数でないとダメです: ~S" x)
    x)
  ; エラー:  偶数で無いとダメです: 1
  ;
  ; Available Restarts:
  ;   0 [continue  ] 値を変更してやり直す。(x)
  ;   1 [abort     ] 評価を中止する。
  ; > 0
  ; `x' の値: 2
  => 2
</description>
<seealso>check-type</seealso>
<link>[CLHS: Macro assert] http://www.lispworks.com/documentation/HyperSpec/Body/m_assert.htm</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>

<chapter>
<title>check-type</title>
<type>Macro</type>
<arguments>check-type PLACE TYPESPEC [STRING]</arguments>
<package>lisp</package>
<description>
PLACE の値が TYPESPEC の型であることを確実にします。

もし PLACE の値が TYPESPEC の型ではなかった場合、store-value 再起動を用
意した上で si::check-type-error を投げます。この store-value 再起動を起
動すると、PLACE の値を置き換えて check-type をやり直します。
PLACE の値が TYPESPEC の型であれば check-type 式は nil を返します。

  PLACE    : 調べる場所。setf できる式を指定します。
  TYPESPEC : typep に渡す型指定をクォートせずに指定します。
  STRING   : TYPESPEC を説明する文字列です。
</description>
<seealso>assert</seealso>
<seealso>typep</seealso>
<seealso>deftype</seealso>
<link>[CLHS: Macro check-type] http://www.lispworks.com/documentation/HyperSpec/Body/m_check_.htm</link>
<section>データ型</section>
<file>condition-restart.l</file>
</chapter>



<chapter>
<title>再起動ってなに</title>
<type>Tips</type>
<description>
エラーが発生した時に適当なところから処理を続行できるようにしておく仕組み
です。

通常、エラーが投げられた場合には handler-case（あるいは handler-bind）で
用意したハンドラで対応しますが、エラーを投げる方（以下、シグナラ）が別の
関数だったりした場合にはハンドラでできることは限られてしまいます。
シグナラ側でエラーを投げる時に restart-case（あるいは restart-bind）でエ
ラーに対応する方法を再起動として用意しておくと、エラーを捕まえたハンドラ
側で適切な再起動を選んで起動することで、シグナラ側でエラーに対応させるこ
とができます。

使用例:
  ;;; シグナラ側
  (defun my-concat (&rest strings)
    (labels ((ensure-string (x)
               (if (typep x 'string)
                 x
                 (restart-case
                     (error 'type-error :datum x :expected-type 'string)
                   (ignore ()
                     :report "この引数を無視する"
                     "") ; 空文字列を concat すると消えて無くなるので
                   (use-value (new-x)
                     :report "他の文字列を使う"
                     :interactive (lambda ()
                                    (list (prompt-for 'string "string> ")))
                     (ensure-string new-x))))))
      (apply #'concat (mapcar #'ensure-string strings))))
  => my-concat
  
  ;; ハンドラなしだとエラーで終了。（condition-restart-support とか使って
  ;; ると再起動を選んで起動できたりします。）
  (my-concat "foo" 'bar "baz")
  >> 不正なデータ型です: bar: string
  
  ;; ハンドラから、不正な引数は無視させる
  (handler-bind
      ((type-error (lambda (err)
                     (let ((r (find-restart 'ignore err)))
                       (when r (invoke-restart r))))))
    (my-concat "foo" 'bar "baz"))
  => "foobaz"
  
  ;; ハンドラから、不正な引数は princ 出力の文字列に変換させる
  (handler-bind
      ((type-error (lambda (err)
                     (let ((r (find-restart 'use-value err)))
                       (when r
                         (let ((replacement
                                 (princ-to-string (type-error-datum err))))
                           (invoke-restart r replacement)))))))
    (my-concat "foo" 'bar "baz"))
  => "foobarbaz"

捕捉:
  handler-case のハンドラは、エラーを捕まえた時点でそれまで実行した結果
  （用意された再起動も含む）を捨ててしまうので、ハンドラから再起動を使う
  場合は handler-bind を使います。
</description>
<seealso>restart-case</seealso>
<seealso>restart-bind</seealso>
<seealso>invoke-restart</seealso>
<seealso>find-restart</seealso>
<seealso>handler-bind</seealso>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>



<chapter>
<title>use-value</title>
<type>Function</type>
<arguments>use-value VALUE &amp;optional CONDITION</arguments>
<package>lisp</package>
<description>
use-value 再起動を起動して、そのときだけ VALUE を使うようにします。
もし有効な use-value 再起動が見つからなかった場合は nil を返します。

use-value 再起動について:
  変数の値がおかしかったりしたときに、そのときだけ代わりの値を使うような
  再起動です。
  変数の値を変更する場合は store-value 再起動を使います。
</description>
<seealso>store-value</seealso>
<link>[CLHS: Function use-value] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_abortc.htm#use-value</link>
<link>[CLHS: Restart use-value] http://www.lispworks.com/documentation/lw50/CLHS/Body/r_use_va.htm</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>

<chapter>
<title>store-value</title>
<type>Function</type>
<arguments>store-value NEW-VALUE &amp;optional CONDITION</arguments>
<package>lisp</package>
<description>
store-value 再起動を起動して、変数の値を NEW-VALUE に変更します。
もし有効な store-value 再起動が見つからなかった場合は nil を返します。

store-value 再起動について:
  変数や汎変数の値を変更して処理を続行するような再起動です
  store-value 再起動を用意するときは、再起動の概要にどの変数の値を変更
  するのか書いておきましょう。
</description>
<seealso>use-value</seealso>
<seealso>check-type</seealso>
<link>[CLHS: Function store-value] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_abortc.htm#store-value</link>
<link>[CLHS: Restart store-value] http://www.lispworks.com/documentation/lw50/CLHS/Body/r_store_.htm</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>

<chapter>
<title>continue</title>
<type>Function</type>
<arguments>continue &amp;optional CONDITION</arguments>
<package>lisp</package>
<description>
continue 再起動を起動して、そのまま処理を続行します。
もし有効な continue 再起動が見つからなかった場合は nil を返してます。

  CONDITION : コンディションを指定すると、そのコンディションに対応した
              continue 再起動を探して起動します。

continue 再起動について:
  単純に処理を続行するような再起動です。
  ※ 警告 (warning) を無視するときは muffle-warning を使います。
</description>
<seealso>restart-case</seealso>
<seealso>abort</seealso>
<seealso>muffle-warning</seealso>
<seealso>store-value</seealso>
<seealso>use-value</seealso>
<seealso>invoke-restart</seealso>
<link>[CLHS: Function continue] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_abortc.htm#continue</link>
<link>[CLHS: Restart continue] http://www.lispworks.com/documentation/lw50/CLHS/Body/r_contin.htm</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>

<chapter>
<title>abort</title>
<type>Function</type>
<arguments>abort &amp;optional CONDITION</arguments>
<package>lisp</package>
<description>
abort 再起動を起動して、処理を中止しようとします。
もし有効な abort 再起動が見つからなかった場合は、quit を投げることで処理
を中止します。

  CONDITION : コンディションを指定すると、そのコンディションに対応した
              abort 再起動を探して起動します。

Common Lisp 処理系では常に abort 再起動が用意されているので、abort 関数
は abort 再起動を起動することで処理を中止しますが、xyzzy ではそんなもの
無かったりするので quit エラーを投げて中止します。
結果として abort 関数は、quit 関数の abort 再起動があれば使うバージョン
のように振る舞います。

abort 再起動について:
  処理を中止するような再起動です。
</description>
<seealso>quit</seealso>
<seealso>restart-case</seealso>
<seealso>invoke-restart</seealso>
<link>[CLHS: Function abort] http://www.lispworks.com/documentation/lw51/CLHS/Body/f_abortc.htm</link>
<link>[CLHS: Restart abort] http://www.lispworks.com/documentation/lw50/CLHS/Body/r_abort.htm</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>

<chapter>
<title>muffle-warning</title>
<type>Function</type>
<arguments>muffle-warning &amp;optional WARNING</arguments>
<package>lisp</package>
<description>
muffle-warning 再起動を起動して、警告を無視します。

  WARNING: 警告を指定すると、その警告に対応した muffle-warning を探して
           起動します。

muffle-warning 再起動について:
  警告を無視する再起動です。warn 関数を参照してください。
</description>
<seealso></seealso>
<link>[CLHS: Function muffle-warning] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_abortc.htm#muffle-warning</link>
<link>[CLHS: Restart muffle-warning] http://www.lispworks.com/documentation/lw50/CLHS/Body/r_muffle.htm</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>



<chapter>
<title>warn</title>
<type>Function</type>
<arguments>warn DATUM &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
※これは condition-restart.l で上書きされた warn の説明です。
警告（warning コンディション）を投げます。

warn 関数は、警告を投げるときに muffle-warning 再起動を用意しておきます。
この muffle-warning 再起動を起動すると警告を無視することができます。

  DATUM, ARGS : 投げる警告を指定します。error 関数を参照してください。
                DATUM にフォーマット文字列を指定した場合は、simple-warning
                を投げます。

投げられた警告が無視も処理もされずにトップレベルまで到達すると、xyzzy は
警告音を鳴らしたりします（共通設定-&gt;いろいろ で設定できます）が、処理
を中止したりはせず、warn 式からは nil が返ります。
</description>
<seealso>error</seealso>
<seealso>signal</seealso>
<seealso>muffle-warning</seealso>
<link>[CLHS: Function warn] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_warn.htm</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>

<chapter>
<title>cerror</title>
<type>Function</type>
<arguments>cerror FMT-CONTROL DATUM &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
回復可能なエラーを投げます。

関数 error 同様に DATUM（及び ARGUMENTSS）で指定されたエラーを投げますが、
そのときに再起動 continue を用意しておきます。
この continue 再起動を起動すると cerror 式から nil を返して、その後の処理
を続行させることができます。

  FMT-CONTROL : 再起動の概要を出力するフォーマット文字列です。引数として
                ARGS が与えられます。
  DATUM, ARGS : 投げるエラーを指定します。詳しくは error 関数を参照してく
                ださい。

ARGS は再起動の概要とエラー指定の両方に使われます。エラー指定に必要だけど
概要の出力には不要なものは "~*" で無視することができます。

</description>
<seealso>signal</seealso>
<seealso>error</seealso>
<link>[CLHS: Function cerror] http://www.lispworks.com/documentation/lw51/CLHS/Body/f_cerror.htm#cerror</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>



<chapter>
<title>compute-restarts</title>
<type>Function</type>
<arguments>compute-restarts &amp;optional CONDITION</arguments>
<package>lisp</package>
<description>
現在の環境で有効な再起動のリストを返します。

引数:
  CONDITION : コンディションオブジェクト、あるいは nil

</description>
<seealso>restart-case</seealso>
<seealso>restart-bind</seealso>
<seealso>with-simple-restart</seealso>
<seealso>find-restart</seealso>
<seealso>invoke-restart</seealso>
<link>[CLHS: Function compute-restarts] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_comp_1.htm#compute-restarts</link>
<file>condition-restart.l</file>
<section>エラー</section>
</chapter>


<chapter>
<title>find-restart</title>
<type>Function</type>
<arguments>find-restart IDENTIFIER &amp;optional CONDITION</arguments>
<package>lisp</package>
<description>
現在の環境で有効な再起動の中から、IDENTIFIER で指定された再起動を探して
見つかればそれを、見つからなければ nil を返します。

引数:
  IDENTIFIER  : シンボルか再起動オブジェクト
  CONDITION   : コンディションオブジェクト

IDENTIFIER にシンボルを与えると、そのシンボルを名前として持つ再起動を探
します。
同名の再起動が複数あった場合、一番最後に用意された再起動が優先されます。
</description>
<seealso>restart-bind</seealso>
<seealso>restart-case</seealso>
<seealso>compute-restarts</seealso>
<link>[CLHS: Function find-restart] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_find_r.htm#find-restart</link>
<file>condition-restart.l</file>
<section>エラー</section>
</chapter>


<chapter>
<title>invoke-restart-interactively</title>
<type>Function</type>
<arguments>invoke-restart-interactively IDENTIFIER</arguments>
<package>lisp</package>
<description>
再起動を対話的に起動します。

  IDENTIFIER : 再起動の名前（シンボル）か再起動オブジェクトを指定します。

再起動を invoke-restart-interactively によって起動すると、その再起動の 
INTERACTIVE-FUNCTION を使って本処理への引数を取得します。

例外:
  INTERACTIVE-FUNCTION は通常ユーザーから引数の入力を受け付け、ユーザー
  がキャンセルするとエラー quit が通知されます。
</description>
<seealso>restart-bind</seealso>
<seealso>restart-case</seealso>
<seealso>invoke-restart</seealso>
<link>[CLHS: Function invoke-restart-interactively] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_invo_2.htm#invoke-restart-interactively</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>


<chapter>
<title>invoke-restart</title>
<type>Function</type>
<arguments>invoke-restart IDENTIFIER &amp;rest ARGUMENTS</arguments>
<package>lisp</package>
<description>
IDENTIFIER で指定される再起動を起動します。

  IDENTIFIER : 起動する再起動の名前（シンボル）か再起動オブジェクトを指
               定します。
  ARGUMENTS  : 再起動に渡す引数があれば。

指定された再起動が見つからなかった場合は restart-not-found エラーを投げ
ます。

通常、再起動はどこかへ制御を飛ばすので invoke-restart で再起動を起動する
と制御は戻ってきませんが、起動した再起動が制御を飛ばさなかった（普通に値
を返した）場合、invoke-restart は再起動が返した値をそのまま返します。
</description>
<seealso>find-restart</seealso>
<seealso>restart-case</seealso>
<link>[CLHS: Function invoke-restart] http://www.lispworks.com/documentation/lw50/CLHS/Body/f_invo_1.htm#invoke-restart</link>
<file>condition-restart.l</file>
<section>エラー</section>
</chapter>



<chapter>
<title>with-simple-restart</title>
<type>Macro</type>
<arguments>with-simple-restart (NAME FMT-CONTROL &amp;rest FMT-ARGUMENTS) &amp;body FORMS</arguments>
<package>lisp</package>
<description>
NAME という名前の再起動を用意した環境で FORMS を評価します。
この再起動が起動されると、with-simple-restart 式は多値で nil と t を返し
て終了します。
</description>
<link>[CLHS: Macro with-simple-restart] http://www.lispworks.com/documentation/lw50/CLHS/Body/m_w_smp_.htm#with-simple-restart</link>
<file>condition-restart.l</file>
</chapter>

<chapter>
<title>with-condition-restarts</title>
<type>Macro</type>
<arguments>with-condition-restarts CONDITION RESTARTS FORM*</arguments>
<package>lisp</package>
<description>
再起動とコンディションを関連付けます。

  CONDITION : コンディションオブジェクト（評価されます）
  RESTARTS  : 再起動のリスト（評価されます）

コンディションと関連付けられた再起動は、関連付けられていないコンディショ
ンを指定して（find-restart や compute-restarts で）再起動を探す場合には
見えなくなります。

例えば、エラー E1 を投げる時に、エラー E1 に対応する再起動 R1 を用意した
とします。
（再起動 R1 がアクティブな状態のまま）全く別のエラー E2 が投げられると、
エラー E2 を捕まえたハンドラからは再起動 R1 も見えますが、再起動 R1 はエ
ラー E1 に対応するための再起動なのでエラー E2 には対応できません。
再起動 R1 とエラー E1 を関連付けておくと、エラー E2 を指定して再起動を探
したときには再起動 R1 は見えなくなるので、何かの間違いで起動してしまうの
を防ぐことができます。

注意:
  どのコンディションにも関連付けられていない再起動は常に見えます。

捕捉:
  restart-case で直接エラーやコンディションを投げると、その restart-case 
  で用意した再起動は自動的に投げるエラーに関連付けられます。

使用例:
  (block example
    (handler-bind
        ((error (lambda (error)
                  (format t "エラー ~A を捕まえました、以下の再起動が見えます:~%~
                             ~{  ~A~%~}"
                    error
                    (compute-restarts error))
                  (return-from example nil))))
      (restart-case
          (let ((E1 (make-condition 'simple-error :format-string "E1")))
            (with-condition-restarts E1 (list (find-restart 'R1))
              (restart-case
                  (error "E2")
                (R2 () "R2"))))
        (R0 () "R0")
        (R1 () "R1"))))
  エラー E2 を捕まえました、以下の再起動が見えます:
    #<restart: R2>
    #<restart: R0>
    #<restart: abort>
  => nil
</description>
<seealso>restart-case</seealso>
<seealso>find-restart</seealso>
<seealso>compute-restarts</seealso>
<link>[CLHS: Macro with-condition-restarts] http://www.lispworks.com/documentation/HyperSpec/Body/m_w_cnd_.htm#with-condition-restarts</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>

<chapter>
<title>restart-case</title>
<type>Macro</type>
<arguments>restart-case FORM RESTART-CLAUSE*</arguments>
<package>lisp</package>
<description>
RESTART-CLAUSE で指定された再起動を用意して FORM を評価します。

FORM の評価が何事もなく終了すればその値を返します。
もし FORM の評価中に（エラーが発生して、それを捕らえたハンドラなどから）
restart-case で用意された再起動が起動されると、与えられた引数を受け取っ
て本処理を実行し、その値を restart-case 式の戻り値として返します。

  (restart-case
      FORM
    (NAME LAMBDA-LIST
      {:interactive INTERACTIVE-EXPR}
      {:report REPORT-EXPR}
      {:test TEST-EXPR}
      BODY...)
    ...)

  FORM         : 任意の式

  NAME         : 再起動の名前（シンボル）
  LAMBDA-LIST  : 再起動の引数（lambda や defun と同じ）
  BODY         : 再起動の本処理

  INTERACTIVE-EXPR :
    対話的に起動された時に、本処理に渡す引数を取得する関数を、関数名で指
    定します。
    invoke-restart-interactively によって再起動が対話的に起動されるとこ
    の関数が引数なしで呼び出されるので、必要に応じてユーザーから入力を受
    け付け、本処理に渡す引数のリストを返してください。

  REPORT-EXPR :
    再起動の概要を、文字列か、概要を出力する関数の関数名で指定します。
    文字列で指定すると、その文字列をそのまま概要として使います。
    関数を指定すると、概要を出力するためにその関数に出力先のストリームを
    与えて呼び出すので、与えられたストリームに概要を出力してください。
    ※再起動を princ 出力したときにも使用されます。

  TEST-EXPR :
    find-restart や compute-restarts で再起動を探す際に、この再起動を有
    効とするか判断する関数を、関数名で指定します。
    再起動を探すときにこの関数が、コンディションオブジェクト（あるいは 
    nil）を引数に呼び出されるので、有効とするなら non-nil を、無効とする
    なら nil を返してください。

  ※「関数名」となっているものは、シンボルか lambda 式をで指定します。
    #' は付けないでください。

使用例:
  ;; 再起動 use-value を用意してエラーを投げる関数
  (defun signaller ()
    (restart-case
        (error "No good reason.")
      (use-value (x)
        x)))
  => signaller
  
  ;; エラーを捕まえて再起動を起動する
  (handler-bind
      ((error (lambda (err)
                (let ((r (find-restart 'use-value err)))
                  (when r (invoke-restart r :restarted))))))
    (signaller))
  => :restarted


捕捉:
  FORM が error, cerror, warn, signal のいずれかの式（あるいは、それに
  展開されるマクロ呼び出し）だった場合、その restart-case で用意される
  再起動は自動的に FORM が投げるコンディションに関連付けられます。
  参考: with-condition-restarts
</description>
<seealso>invoke-restart</seealso>
<seealso>with-simple-restart</seealso>
<seealso>restart-bind</seealso>
<seealso>with-condition-restarts</seealso>
<link>[CLHS: Function restart-case] http://www.lispworks.com/documentation/lw50/CLHS/Body/m_rst_ca.htm</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>

<chapter>
<title>restart-bind</title>
<type>Macro</type>
<arguments>restart-bind (RESTART*) FORM*</arguments>
<package>lisp</package>
<description>
RESTART* で指定された再起動を用意して FORM* を評価します。

FORM* が何事もなく終了すれば、その値を返します。
もし FORM* の評価中に（エラーが発生して、それを捕らえたハンドラから、な
ど）再起動が起動されると、起動された再起動の RESTART-FUNCTION を呼び出し
ます。

  (restart-bind ((NAME RESTART-FUNCTION
                   {:interactive-function INTERACTIVE-FUNCTION}
                   {:report-function REPORT-FUNCTION}
                   {:test-function TEST-FUNCTION})
                 ...)
    FORM*)

restart-bind で用意される再起動は（restart-case と違って）、起動されると 
RESTART-FUNCTION を呼び出すだけで、どこかへ制御を移したりはしません。必
要に応じて return-form で block からリターンしたり、tagbody や prog でタ
グを用意しておいて go でジャンプするなどして、適当なところへ制御を移す必
要があります。

INTERACTIVE-FUNCTION, REPORT-FUNCTION, TEST-FUNCTION の各関数については、
指定方法が違うだけで使われ方は restart-case と同じなので、そちらを参照し
てください。

捕捉:
  restart-bind は再起動の基本的な仕組みを提供するだけのマクロなので、た
  いていの場合は restart-case の方が便利かと思います。

参考:
  restart-case は restart-bind を使って実装されています。

      (restart-case
          任意の式
        (名前 (仮引数)
          <オプション>
          本処理..))

  という restart-case 式は、だいたい以下に展開されます。

      (block #1=#:restart-case
        (let ((#2=#:args nil))
          (tagbody
            (restart-bind ((名前 (lambda (&rest temp)
                                   (setq #2# temp)
                                   (go #3=#:restart))
                             <整形したオプション>))
              (return-from #1# FORM))
            #3# (return-from #1#
                  (apply #'(lambda (仮引数) 本処理..) #2#)))))
</description>
<seealso>with-simple-restart</seealso>
<seealso>restart-case</seealso>
<seealso>invoke-restart</seealso>
<link>[CLHS: Macro restart-bind] http://www.lispworks.com/documentation/lw50/CLHS/Body/m_rst_bi.htm</link>
<section>エラー</section>
<file>condition-restart.l</file>
</chapter>

</book>
