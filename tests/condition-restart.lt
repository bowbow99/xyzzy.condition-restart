;;; -*- mode: lisp; package: test.condition-restart -*-
;;;
;;; tests/condition-restart.lt
;;;

(require "condition-restart")
(require "lisp-unit")
(require "typespec+")

(defpackage :test.condition-restart
  (:use :lisp :lisp-unit :typespec+))

(in-package :test.condition-restart)

(remove-all-tests :test.condition-restart)

;;;;
;;;; * Utilities

(deftype list-of (element-type)
  `(and list
        (satisfies (lambda (x)
                     (every (typepred ,element-type) x)))))


;;;;
;;;; * restart-case

(define-test restart-case-establish-findable-restarts
  "Macro restart-case establish restarts, and those can be found via
find-restart and compute-restarts."
  (let ((restart (restart-case
                     (find-restart 'foo)
                   (foo ())
                   (bar ())
                   (baz ()))))
    (assert-true restart)
    (assert-eql 'foo (restart-name restart)))
  (let ((restarts (restart-case
                      (compute-restarts)
                    (foo ())
                    (bar ())
                    (baz ()))))
    (assert-type (list-of condition-restart::restart) restarts)
    (assert-true (>= (length restarts) 3))
    (assert-true (find 'foo restarts :key 'restart-name))
    (assert-true (find 'bar restarts :key 'restart-name))
    (assert-true (find 'baz restarts :key 'restart-name))))


(define-test restart-is-visible-in-upper-handlers
  "Restarts are visible from error handlers established in somewhere in
`upper'."
  (assert-type
   condition-restart::restart
   (block test
     (handler-bind ((simple-error (lambda (e)
                                    (return-from test
                                      (find-restart 'foo)))))
       (restart-case
           (error "error")
         (foo ())))))
  (assert-type (list-of condition-restart::restart)
   (block test
     (handler-bind ((simple-error (lambda (e)
                                    (return-from test
                                      (compute-restarts)))))
       (restart-case
           (error "error")
         (foo ())
         (bar ())
         (baz ()))))))


(define-test restart-case-returns-value-from-form
  "when FORM returned normally, restart-case returns the value returned
from FORM."
  (assert-eql 'foo (restart-case 'foo))
  (assert-eql 'normal-foo
      (restart-case 'normal-foo
        (foo () 'restart-foo)))
  (assert-eql 'normal-foo
      (restart-case
          (progn
            (find-restart 'foo)
            'normal-foo)
        (foo () 'restart-foo))))


(define-test restart-case-returns-value-from-restart-body
  "when restart established by restart-case invoked, restart-case returns
the values that body of restart returned."
  (assert-eql 'foo
      (restart-case
          (invoke-restart (find-restart 'foo))
        (foo () 'foo)))
  (assert-eql 'foo
      (restart-case
          (invoke-restart (find-restart 'foo) 'foo)
        (foo (x) x)))
  (assert-eql :restarted
      (restart-case
          (progn
            (invoke-restart (find-restart 'foo))
            :normal-return)
        (foo () :restarted))))


;;;;
;;;; * Restart-bind:

(define-test restart-bind-return-what-forms-returned
  (assert-eql 3 (restart-bind () (+ 1 2)))
  (assert-eql :foo (restart-bind () :foo))
  (assert-eql nil (restart-bind ()))
  (assert-eql nil (restart-bind () nil)))

(define-test restart-bind-doesnt-stop-error
  (assert-error 'type-error (restart-bind () (error 'type-error :datum 3 :expected-type 'string)))
  (assert-error 'division-by-zero (restart-bind () (/ 1 0))))

(define-test restart-bind-establish-findable-restarts
  (let ((restart (restart-bind ((foo (lambda () :foo)))
                   (find-restart 'foo))))
    (assert-type condition-restart::restart restart)
    (assert-eql 'foo (restart-name restart)))
  (let ((restarts (restart-bind ((foo (lambda () :foo))
                                 (bar (lambda () :bar))
                                 (baz (lambda () :baz)))
                    (compute-restarts))))
    (assert-type (list-of condition-restart::restart) restarts)
    (assert-true (find 'foo restarts :key 'restart-name))
    (assert-true (find 'bar restarts :key 'restart-name))
    (assert-true (find 'baz restarts :key 'restart-name))))

(define-test restart-via-restart-bind-does-not-transfer-control
  (assert-eql :normal-return
      (restart-bind ((foo (lambda () :restart-return)))
        (invoke-restart (find-restart 'foo))
        :normal-return))
  (let ((executed-p nil))
    (assert-eql :normal-return
        (restart-bind ((foo (lambda ()
                              (setf executed-p t)
                              :restart-return)))
          (invoke-restart (find-restart 'foo))
          :normal-return))
    (assert-true executed-p)))


;;;;
;;;; * Restart visibility (TEST-FUNCTION)

(define-test restart-visibility-by-test-function
  "If TEST-FUNCTION returns nil, the restart can not be found."
  (assert-type condition-restart::restart
               (restart-case
                   (find-restart 'foo)
                 (foo ()
                   :test (lambda (condition) t))))
  (assert-type null
               (restart-case
                   (find-restart 'foo)
                 (foo ()
                   :test (lambda (condition) nil))))
  (assert-type condition-restart::restart
               (let ((w (make-condition 'simple-warning)))
                 (restart-case
                     (find-restart 'foo w)
                   (foo ()
                     :test (lambda (condition) (eql condition w))))))
  (assert-type null
               (let ((w (make-condition 'simple-warning)))
                 (restart-case
                     (find-restart 'foo)
                   (foo ()
                     :test (lambda (condition) (eql condition w)))))))

;;;;
;;;; * Restart visibility (Active or not)

(define-test restart-visibility-by-active-or-not
  "If restart is not active, it can not be found.
In other words, restart can be found only in the form that estalbish the restart."
  (assert-eql nil
      (progn
        (restart-case t
          (foo ()))
        (find-restart 'foo)))
  (assert-eql nil
      (prog1
          (find-restart 'foo)
        (restart-case t
          (foo ()))))
  (assert-eql nil
      (let ((restart (restart-case
                         (find-restart 'foo)
                       (foo ()))))
        (find-restart restart))))

;;;;
;;;; * Restart visibility (Association)

(define-test restart-visibility-by-association
  "If restart is associated with one or more conditions, they can not be found
for conditions those aren't associated with the restart."
  (let ((c1 (make-condition 'simple-error))
        (c2 (make-condition 'simple-error)))
    (restart-case
        (with-condition-restarts c1 (list (find-restart 'foo))
          (with-condition-restarts c2 (list (find-restart 'bar))
            ;; for no condition
            (assert-type condition-restart::restart (find-restart 'foo))
            (assert-type condition-restart::restart (find-restart 'bar))
            (assert-type condition-restart::restart (find-restart 'baz))
            ;; for c1
            (assert-type condition-restart::restart (find-restart 'foo c1))
            (assert-eql  nil (find-restart 'bar c1))
            (assert-type condition-restart::restart (find-restart 'baz))
            ;; for c2
            (assert-eql nil (find-restart 'foo c2))
            (assert-type condition-restart::restart (find-restart 'bar c2))
            (assert-type condition-restart::restart (find-restart 'baz))))
      (foo ())
      (bar ())
      (baz ()))))

(define-test restart-case-associates-restart-if-error
  "If FORM is to signal a condition, restart-case associates its own restarts
to the condition to be signalled."
  (let ((c1 (make-condition 'simple-error))
        (c2 (make-condition 'simple-error)))
    (macrolet ((find-restart-foo (error &optional condition)
                 "Find restart `foo` for given CONDITION from handler."
                 `(block test
                    (handler-bind
                        ((simple-error (lambda (e)
                                         (return-from test
                                           (find-restart 'foo ,condition)))))
                      (restart-case
                          (error ,error)
                        (foo ()))))))
      ;; signal `c1` == not visible for `c2`
      (assert-type condition-restart::restart (find-restart-foo c1))
      (assert-type condition-restart::restart (find-restart-foo c1 c1))
      (assert-eql nil (find-restart-foo c1 c2))
      ;; signal `c2` == not visible for `c1`
      (assert-type condition-restart::restart (find-restart-foo c2))
      (assert-eql nil (find-restart-foo c2 c1))
      (assert-type condition-restart::restart (find-restart-foo c2 c2)))))

;;; tests/condition-restart.lt ends here.
